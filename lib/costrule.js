/** @module calcost/costrule
 *
 * @copyright Michael McCarthy <michael.mccarthy@ieee.org> 2017
 * @license MIT
 */

'use strict';

/* dependencies */
const _ = require('lodash');
const caltime = require('caltime');
const modconst = require('./constants');

/* local constants */
/** Default number of hours in a standard work day */
const DEFAULT_WORK_DAY_HOURS = 8;
/* maximum number of hours in a day */
const MAX_HOURS_PER_DAY = 24;
/* number of minutes per hour */
const MINS_PER_HOUR = 60;

/**
 * Functional constructor. Creates an instance of CostRule.
 * Each CostRule object is immutable.
 * @param {Object} inTimeRule A TimeRule object which represents the time
 * interval during which this rule applies i.e. if a timespan overlaps with
 * a timespan generated by this TimeRule then costs may apply, otherwise no
 * costs are accumulated.
 * @param {number} inRate Floating point number. Cost accumulated per unit of
 * time. How exactly the cost is calculated depends on inRateType.
 * @param {number} inRateType Integer defining how the cost per unit of time
 * is calculated.
 * @param {number} inWorkDayDuration Number of minutes in a standard work day.
 * This argument is only required if the rate type is RATETYPE_PER_DAY_PRORATA
 * or RATETYPE_PER_DAY_ROUNDUP.
 * Argument is optional. If it is defined then it must be a positive number and
 * less than or equal to 1440 minutes (24 hours). If not defined then a
 * default value of 480 minutes (8 hours) is used.
 * @return {Object} A new instance of a CostRule object.
 * @throws {Error}
 */
let costRule = function costRuleFunc(inTimeRule,
                                        inRate,
                                        inRateType,
                                        inWorkDayDuration=(DEFAULT_WORK_DAY_HOURS*MINS_PER_HOUR)) {
  /** private *****************************************************************/
  /* new instance of object */
  const that = {};

  if (_.isObject(inTimeRule) === false) {
    throw new Error('Invalid TimeRule argument passed to method.');
  }
  if (_.isInteger(inRateType) === false) {
    throw new Error('Invalid rate type argument passed to method.');
  }
  if (_.isFinite(inRate) === false) {
    throw new Error('Invalid rate argument passed to method.');
  }
  if (inRateType < modconst.RATETYPE_MIN_VALUE
      || inRateType > modconst.RATETYPE_MAX_VALUE) {
    throw new Error('Invalid argument. inRateType outside permitted range.');
  }
  if(inWorkDayDuration <= 0
      || inWorkDayDuration >= (MAX_HOURS_PER_DAY*MINS_PER_HOUR)) {
    throw new RangeError('Argument inWorkDayDuration outside permitted range.');
  }

  /* timerule describes when costs are accumulated due to this rule */
  const timerule = inTimeRule
  /* rate per unit of time */
  const rate = inRate;
  /* type of rate */
  const rateType = inRateType;
  /* number of hours in a standard work day */
  const workDayDurationMins = inWorkDayDuration;

  /** public methods **********************************************************/

  /**
   * Get the TimeRule of the CostRule.
   * @return {Object} TimeSpan object.
   */
  that.getTimeRule = function getTimeRuleFunc() {
    return timerule;
  };

  /**
   * Get the cost per unit of time.
   * @return {number} Floating point number. Rate is cost per unit.
   */
  that.getRate = function getRateFunc() {
    return rate;
  };

  /**
   * Get the rate type of the CostRule.
   * @return {number} Integer. Rate type indicates how the cost is calculated
   * by this CostRule.
   */
  that.getRateType = function getRateTypeFunc() {
    return rateType;
  };

  /**
   * Get the number of minutes in a standard workday, as defined for this rule.
   * @return {number} Positive real number. Duration of a workday in minutes.
   */
  that.getWorkDayDuration = function getWorkDayDurationFunc() {
    return workDayDurationMins;
  };

  /**
   * Starting from a specific date and time, get all of the date-spans which are
   * created by this time rule.
   * @param {Array} inDateSpans Array of DateSpan objects for which the total
   * cost must be calculated.
   * @return {Object} Object containing the results of the calculation. The
   * object has three data members:
   * - cost: Total cost of all the intervals of time whose cost could be
   * calculated by the CostRule.
   * - usedSpans: Array of DateSpan objects. These DateSpans did contribute to
   * the total cost value.
   * - remainderSpans: Array of DateSpan objects. These DateSpans did not
   * contribute to the total cost value.
   */
  that.totalCost = function totalCostFunc(inDateSpans) {
    const retval = {
      cost: 0.0,
      usedSpans: [],
      remainderSpans: []
    };
    if (_.isArray(inDateSpans) === false) {
        throw new TypeError('Invalid argument. Must be of type Array.');
    }
    // sort and merge the timespans
    const mergedSpans = caltime.mergeDateSpans(inDateSpans);
    // find the earliest and latest dates
    let earliestSpan = null;
    let latestSpan = null;
    if(inDateSpans.length > 0) {
      earliestSpan = inDateSpans[0];
      latestSpan = inDateSpans[inDateSpans.length-1];
    }
    // range of datespans for time-rule
    const ruleSpans = timerule.generateDateSpans(earliestSpan.getBegin(),
                                                  latestSpan.getEnd());
    // identify all overlaps
    const overlaps = caltime.intersectDateSpans(ruleSpans, inDateSpans);
    // calculate cost of each overlap
    _.forEach(overlaps,
              function costSumFunc(inValue, inIndex) {

              });
    // generate the remainders
    // TODO
    return retval;
  };

  /** private methods *********************************************************/

  /**
   * Calculate the cost of a single DateSpan object.
   * @param {object} inDateSpan A valid DateSpan object.
   * @return {number} Floating point number with the cost of the DateSpan or
   * null if there is no overlap with interval of the CostRule.
   */
  let costOf = function costOfFunc(inDateSpan) {

    let retval = false;
    if (_.isObject(inDateSpan) === false) {
        throw new TypeError('Invalid argument. Must be of type DateSpan.');
    }
    // range of datespans for time-rule
    const ruleSpans = timerule.generateDateSpans(inDateSpan.getBegin(),
                                                  inDateSpan.getEnd());
    // identify all overlaps
    const overlaps = caltime.intersectDateSpans(ruleSpans, inDateSpans);


    return retval;
  }

/* functional constructor return */
return that;
};


/** public functions **********************************************************/


/* interface exported by the module */
module.exports.costRule = costRule;


/** private functions *********************************************************/
