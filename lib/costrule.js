/** @module calcost/costrule
 *
 * @copyright Michael McCarthy <michael.mccarthy@ieee.org> 2017
 * @license MIT
 */

'use strict';

/* dependencies */
const _ = require('lodash');

const modconst = require('./constants');


/**
 * Functional constructor. Creates an instance of CostRule.
 * Each CostRule object is immutable.
 * @param {Object} inTimeRule A TimeRule object which represents the time
 * interval during which this rule applies i.e. if a timespan overlaps with
 * a timespan generated by this TimeRule then costs may apply, otherwise no
 * costs are accumulated.
 * @param {number} inRate Floating point number. Cost accumulated per unit of
 * time. How exactly the cost is calculated depends on inRateType.
 * @param {number} inRateType Integer defining how the cost per unit of time
 * is calculated.
 * @return {Object} A new instance of a CostRule object.
 * @throws {Error}
 */
let costRule = function costRuleFunc(inTimeRule,
                                        inRate,
                                        inRateType) {
  /** private *****************************************************************/
  /* new instance of object */
  const that = {};

  if (_.isObject(inTimeRule) === false) {
    throw new Error('Invalid TimeRule argument passed to method.');
  }
  if (_.isInteger(inRateType) === false) {
    throw new Error('Invalid rate type argument passed to method.');
  }
  if (_.isFinite(inRate) === false) {
    throw new Error('Invalid rate argument passed to method.');
  }
  if (inRateType < modconst.RATETYPE_MIN_VALUE
      || inRateType > modconst.RATETYPE_MAX_VALUE) {
    throw new Error('Invalid argument. inRateType outside permitted range.');
  }

  /* timerule describes when costs are accumulated due to this rule */
  const timerule = inTimeRule
  /* rate per unit of time */
  const rate = inRate;
  /* type of rate */
  const rateType = inRateType;

  /** public methods **********************************************************/

  /**
   * Get the TimeRule of the CostRule.
   * @return {Object} TimeSpan object.
   */
  that.getTimeRule = function getTimeRuleFunc() {
    return timerule;
  };

  /**
   * Get the rate per unit of the TimeRule.
   * @return {number} Floating point number. Rate is cost per unit.
   */
  that.getRate = function getRateFunc() {
    return rate;
  };

  /**
   * Get the rate type of the CostRule.
   * @return {number} Integer. Rate type indicates how the cost is calculated
   * by this CostRule.
   */
  that.getRateType = function getRateTypeFunc() {
    return rateType;
  };

  /**
   * Starting from a specific date and time, get all of the date-spans which are
   * created by this time rule.
   * @param {Array} inDateSpans Array of DateSpan objects for which the total
   * cost must be calculated.
   * @param {Date} inEnd Time up to which the rule generates date-spans. Must be
   * a valid Date object and after the inBegin time.
   * @return {Object[]} Array of DateSpan objects.
   */
  that.totalCost = function totalCostFunc(inDateSpans) {
    let retval = {};
    if (_.isArray(inDateSpans) === false) {
        throw new Error('Invalid argument. Must be of type DateSpan.');
    }
    // TODO implement method
    return retval;
  };

  /** private methods *********************************************************/


/* functional constructor return */
return that;
};


/** public functions **********************************************************/


/* interface exported by the module */
module.exports.costRule = costRule;


/** private functions *********************************************************/
