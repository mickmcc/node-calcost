/** @module calcost/costrule
 *
 * @copyright Michael McCarthy <michael.mccarthy@ieee.org> 2017
 * @license MIT
 */

'use strict';

/* dependencies */
const moment = require('moment-timezone');
const _ = require('lodash');
const caltime = require('caltime');
const modconst = require('./constants');

/* local constants */
/** Default number of hours in a standard work day */
const DEFAULT_WORK_DAY_HOURS = 8;
/* maximum number of hours in a day */
const MAX_HOURS_PER_DAY = 24;
/* number of minutes per hour */
const MINS_PER_HOUR = 60;

/**
 * Functional constructor. Creates an instance of CostRule.
 * Each CostRule object is immutable.
 * @param {Object} inTimeRule A TimeRule object which represents the time
 * interval during which this rule applies i.e. if a timespan overlaps with
 * a timespan generated by this TimeRule then costs may apply, otherwise no
 * costs are accumulated.
 * @param {number} inRate Floating point number. Cost accumulated per unit of
 * time. How exactly the cost is calculated depends on inRateType.
 * @param {number} inRateType Integer defining how the cost per unit of time
 * is calculated. Valid values are defined as constants in the 'constants' object.
 * @param {number} inWorkDayDuration Number of minutes in a standard work day.
 * This argument is only required if the rate type is RATETYPE_PER_DAY_PRORATA
 * or RATETYPE_PER_DAY_ROUNDUP.
 * Argument is optional. If it is defined then it must be a positive number and
 * less than or equal to 1440 minutes (24 hours). If not defined then a
 * default value of 480 minutes (8 hours) is used.
 * @return {Object} A new instance of a CostRule object.
 * @throws {Error}
 */
let costRule = function costRuleFunc(inTimeRule,
                                        inRate,
                                        inRateType,
                                        inWorkDayDuration=(DEFAULT_WORK_DAY_HOURS*MINS_PER_HOUR)) {
  /** private *****************************************************************/
  /* new instance of object */
  const that = {};

  if (_.isObject(inTimeRule) === false) {
    throw new Error('Invalid TimeRule argument passed to method.');
  }
  if (_.isInteger(inRateType) === false) {
    throw new Error('Invalid rate type argument passed to method.');
  }
  if (_.isFinite(inRate) === false) {
    throw new Error('Invalid rate argument passed to method.');
  }
  if (inRateType < modconst.RATETYPE_MIN_VALUE
      || inRateType > modconst.RATETYPE_MAX_VALUE) {
    throw new Error('Invalid argument. inRateType outside permitted range.');
  }
  if(inWorkDayDuration <= 0
      || inWorkDayDuration >= (MAX_HOURS_PER_DAY*MINS_PER_HOUR)) {
    throw new RangeError('Argument inWorkDayDuration outside permitted range.');
  }

  /* timerule describes when costs are accumulated due to this rule */
  const timerule = inTimeRule
  /* rate per unit of time */
  const rate = inRate;
  /* type of rate */
  const rateType = inRateType;
  /* number of hours in a standard work day */
  const workDayDurationMins = inWorkDayDuration;

  /** public methods **********************************************************/

  /**
   * Get the TimeRule of the CostRule.
   * @return {Object} TimeSpan object.
   */
  that.getTimeRule = function getTimeRuleFunc() {
    return timerule;
  };

  /**
   * Get the cost per unit of time.
   * @return {number} Floating point number. Rate is cost per unit.
   */
  that.getRate = function getRateFunc() {
    return rate;
  };

  /**
   * Get the rate type of the CostRule.
   * @return {number} Integer. Rate type indicates how the cost is calculated
   * by this CostRule.
   */
  that.getRateType = function getRateTypeFunc() {
    return rateType;
  };

  /**
   * Get the number of minutes in a standard workday, as defined for this rule.
   * @return {number} Positive real number. Duration of a workday in minutes.
   */
  that.getWorkDayDuration = function getWorkDayDurationFunc() {
    return workDayDurationMins;
  };

  /**
   * Starting from a specific date and time, get all of the date-spans which are
   * created by this time rule.
   * @param {Array} inDateSpans Array of DateSpan objects for which the total
   * cost must be calculated.
   * @param {string} inTZ Timezone identifier as defined by the
   * tz database - sometimes called the TZ environment variable value.
   * See https://www.iana.org/time-zones for more details.
   * If no timezone argument is passed then the local timezone will be used.
   * The timezone, which is to be used for the cost calculation, is required as
   * it can affect calculations based on hourly or daily rates.
   * @return {Object} Object containing the results of the calculation. The
   * object has three data members:
   * - cost: Total cost of all the intervals of time whose cost could be
   * calculated by the CostRule.
   * - usedSpans: Array of DateSpan objects. These DateSpans did contribute to
   * the total cost value.
   * - remainderSpans: Array of DateSpan objects. These DateSpans did not
   * contribute to the total cost value.
   */
  that.totalCost = function totalCostFunc(inDateSpans, inTZ=null) {
    const retval = {
      cost: 0.0,
      usedSpans: [],
      remainderSpans: []
    };
    let timezone = inTZ;
    let durationType = modconst.RATETYPE_PER_MILLISECOND;

    if (_.isArray(inDateSpans) === false) {
        throw new TypeError('Invalid argument. Must be of type Array.');
    }
    if(inTZ !== null
        && (_.isString(inTZ) === false
            || moment.tz.zone(inTZ) === null
            || moment.tz('2001-01-01', inTZ).isValid() === false)) {
      throw new Error(`Invalid argument. Invalid TZ identifier string: ${inTZ}`);
    }
    // caller didn't specify timezone so use local timezone
    if(timezone === null) {
      timezone = moment().format('ZZ');
    }
    // sort and merge the timespans
    const mergedSpans = caltime.mergeDateSpans(inDateSpans);
    // find the earliest and latest dates
    let earliestSpan = null;
    let latestSpan = null;
    if(inDateSpans.length > 0) {
      earliestSpan = mergedSpans[0];
      latestSpan = mergedSpans[mergedSpans.length-1];
    }
    // range of datespans for time-rule
    const ruleSpans = timerule.generateDateSpans(earliestSpan.getBegin(),
                                                  latestSpan.getEnd());
    // identify all overlaps
    const overlaps = caltime.intersectDateSpans(ruleSpans, inDateSpans);
    // calculate cost of each overlap
    if(rateType === modconst.RATETYPE_PER_MINUTE_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_MINS;
    }
    else if(rateType === modconst.RATETYPE_PER_HOUR_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_HOURS;
    }
    else if(rateType === modconst.RATETYPE_PER_DAY_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_DAYS;
    }
    let measureResult = caltime.measureDateSpans(overlaps,
                                            durationType,
                                            inTZ);
    switch(rateType) {
      case modconst.RATETYPE_PER_MILLISECOND:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_SECOND_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_SEC) * rate;
        break;
      case modconst.RATETYPE_PER_SECOND_ROUNDUP:
        let durationSecs = Math.floor(measureResult / 1000);
        retval.cost = durationSecs * rate;
        if(durationSecs * 1000 < measureResult) {
          retval.cost += rate;
        }
        break;
      case modconst.RATETYPE_PER_MINUTE_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_MIN) * rate;
        break;
      case modconst.RATETYPE_PER_MINUTE_ROUNDUP:
        let durationMins = Math.floor(measureResult / caltime.constants.MSECS_PER_MIN);
        retval.cost = durationMins * rate;
        if((durationMins * caltime.constants.MSECS_PER_MIN) < measureResult) {
          retval.cost += rate;
        }
        break;
      case modconst.RATETYPE_PER_MINUTE_NATURAL:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_HOUR_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_HOUR) * rate;
        break;
      case modconst.RATETYPE_PER_HOUR_ROUNDUP:
        let durationHours = Math.floor(measureResult / caltime.constants.MSECS_PER_HOUR);
        retval.cost = durationHours * rate;
        if((durationHours * caltime.constants.MSECS_PER_HOUR) < measureResult) {
          retval.cost += rate;
        }
        break;
      case modconst.RATETYPE_PER_HOUR_NATURAL:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_DAY_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_DAY) * rate;
        break;
      case modconst.RATETYPE_PER_DAY_ROUNDUP:
        let durationDays = Math.floor(measureResult / caltime.constants.MSECS_PER_DAY);
        retval.cost = durationDays * rate;
        if((durationDays * caltime.constants.MSECS_PER_DAY) < measureResult) {
          retval.cost += rate;
        }
        break;
      case modconst.RATETYPE_PER_DAY_NATURAL:
        retval.cost = measureResult * rate;
        break;
    }
    // calculate the overlaps used for cost
    // TODO improve implementation
    let i = 0;
    for(i=0; i<overlaps.length; i++) {
      retval.usedSpans.push(overlaps[i]);
    }
    // calculate the remainders not used for cost
    i = 0;
    let j = 0;
    // iterate over input datespans
    while(i<inDateSpans.length) {
      let dateSpan = inDateSpans[i];
      // iterate over overlap datespans
      while(j<overlaps.length) {
        let overlapSpan = overlaps[j];
        if(overlapSpan.isIntersect(dateSpan)) {
          let remainders = dateSpan.subtract(overlapSpan);
          if(remainders.length >= 1) {
            retval.remainderSpans.push(remainders[0]);
          }
          if(remainders.length == 2) {
            retval.remainderSpans.push(remainders[1]);
          }
          break;
        }
        else if(j >= (overlaps.length-1)) {
          retval.remainderSpans.push(dateSpan);
        }
        j++;
      }
      if(overlaps.length === 0) {
        retval.remainderSpans.push(dateSpan);
      }
      i++;
    }
    return retval;
  };

  /** private methods *********************************************************/


/* functional constructor return */
return that;
};


/** public functions **********************************************************/


/* interface exported by the module */
module.exports.costRule = costRule;


/** private functions *********************************************************/
