/** @module calcost/costrule
 *
 * @copyright Michael McCarthy <michael.mccarthy@ieee.org> 2017
 * @license MIT
 */

'use strict';

/* dependencies */
const moment = require('moment-timezone');
const _ = require('lodash');
const caltime = require('caltime');
const modconst = require('./constants');

/* local constants */
/** Default number of hours in a standard work day */
const DEFAULT_WORK_DAY_HOURS = 8;
/* maximum number of hours in a day */
const MAX_HOURS_PER_DAY = 24;
/* number of minutes per hour */
const MINS_PER_HOUR = 60;

/**
 * Functional constructor. Creates an instance of CostRule.
 * Each CostRule object is immutable.
 * @param {Object} inTimeRule A TimeRule object which represents the time
 * interval during which this rule applies i.e. if a timespan overlaps with
 * a timespan generated by this TimeRule then costs may apply, otherwise no
 * costs are accumulated.
 * @param {number} inRate Floating point number. Cost accumulated per unit of
 * time. How exactly the cost is calculated depends on inRateType.
 * @param {number} inRateType Integer defining how the cost per unit of time
 * is calculated.
 * @param {number} inWorkDayDuration Number of minutes in a standard work day.
 * This argument is only required if the rate type is RATETYPE_PER_DAY_PRORATA
 * or RATETYPE_PER_DAY_ROUNDUP.
 * Argument is optional. If it is defined then it must be a positive number and
 * less than or equal to 1440 minutes (24 hours). If not defined then a
 * default value of 480 minutes (8 hours) is used.
 * @return {Object} A new instance of a CostRule object.
 * @throws {Error}
 */
let costRule = function costRuleFunc(inTimeRule,
                                        inRate,
                                        inRateType,
                                        inWorkDayDuration=(DEFAULT_WORK_DAY_HOURS*MINS_PER_HOUR)) {
  /** private *****************************************************************/
  /* new instance of object */
  const that = {};

  if (_.isObject(inTimeRule) === false) {
    throw new Error('Invalid TimeRule argument passed to method.');
  }
  if (_.isInteger(inRateType) === false) {
    throw new Error('Invalid rate type argument passed to method.');
  }
  if (_.isFinite(inRate) === false) {
    throw new Error('Invalid rate argument passed to method.');
  }
  if (inRateType < modconst.RATETYPE_MIN_VALUE
      || inRateType > modconst.RATETYPE_MAX_VALUE) {
    throw new Error('Invalid argument. inRateType outside permitted range.');
  }
  if(inWorkDayDuration <= 0
      || inWorkDayDuration >= (MAX_HOURS_PER_DAY*MINS_PER_HOUR)) {
    throw new RangeError('Argument inWorkDayDuration outside permitted range.');
  }

  /* timerule describes when costs are accumulated due to this rule */
  const timerule = inTimeRule
  /* rate per unit of time */
  const rate = inRate;
  /* type of rate */
  const rateType = inRateType;
  /* number of hours in a standard work day */
  const workDayDurationMins = inWorkDayDuration;

  /** public methods **********************************************************/

  /**
   * Get the TimeRule of the CostRule.
   * @return {Object} TimeSpan object.
   */
  that.getTimeRule = function getTimeRuleFunc() {
    return timerule;
  };

  /**
   * Get the cost per unit of time.
   * @return {number} Floating point number. Rate is cost per unit.
   */
  that.getRate = function getRateFunc() {
    return rate;
  };

  /**
   * Get the rate type of the CostRule.
   * @return {number} Integer. Rate type indicates how the cost is calculated
   * by this CostRule.
   */
  that.getRateType = function getRateTypeFunc() {
    return rateType;
  };

  /**
   * Get the number of minutes in a standard workday, as defined for this rule.
   * @return {number} Positive real number. Duration of a workday in minutes.
   */
  that.getWorkDayDuration = function getWorkDayDurationFunc() {
    return workDayDurationMins;
  };

  /**
   * Starting from a specific date and time, get all of the date-spans which are
   * created by this time rule.
   * @param {Array} inDateSpans Array of DateSpan objects for which the total
   * cost must be calculated.
   * @param {string} inTZ Timezone identifier as defined by the
   * tz database - sometimes called the TZ environment variable value.
   * See https://www.iana.org/time-zones for more details.
   * If no timezone argument is passed then the local timezone will be used.
   * The timezone, which is to be used for the cost calculation, is required as
   * it can affect calculations based on hourly or daily rates.
   * @return {Object} Object containing the results of the calculation. The
   * object has three data members:
   * - cost: Total cost of all the intervals of time whose cost could be
   * calculated by the CostRule.
   * - usedSpans: Array of DateSpan objects. These DateSpans did contribute to
   * the total cost value.
   * - remainderSpans: Array of DateSpan objects. These DateSpans did not
   * contribute to the total cost value.
   */
  that.totalCost = function totalCostFunc(inDateSpans, inTZ=null) {
    const retval = {
      cost: 0.0,
      usedSpans: [],
      remainderSpans: []
    };
    let timezone = inTZ;
    let durationType = modconst.RATETYPE_PER_MILLISECOND;

    if (_.isArray(inDateSpans) === false) {
        throw new TypeError('Invalid argument. Must be of type Array.');
    }
    if(inTZ !== null
        && (_.isString(inTZ) === false
            || moment.tz.zone(inTZ) === null
            || moment.tz('2001-01-01', inTZ).isValid() === false)) {
      throw new Error(`Invalid argument. Invalid TZ identifier string: ${inTZ}`);
    }
    // caller didn't specify timezone so use local timezone
    if(timezone === null) {
      timezone = moment().format('ZZ');
    }
    // sort and merge the timespans
    const mergedSpans = caltime.mergeDateSpans(inDateSpans);
    // find the earliest and latest dates
    let earliestSpan = null;
    let latestSpan = null;
    if(inDateSpans.length > 0) {
      earliestSpan = inDateSpans[0];
      latestSpan = inDateSpans[inDateSpans.length-1];
    }
    console.log(`totalcost() earliestSpan.getBegin(): ${earliestSpan.getBegin()}`); // debug
    console.log(`totalcost() latestSpan.getEnd(): ${latestSpan.getEnd()}`); // debug
    // range of datespans for time-rule
    const ruleSpans = timerule.generateDateSpans(earliestSpan.getBegin(),
                                                  latestSpan.getEnd());
    console.log(`totalcost() ruleSpans: ${ruleSpans}`); // debug
    // identify all overlaps
    const overlaps = caltime.intersectDateSpans(ruleSpans, inDateSpans);
    console.log(`totalcost() overlaps.length: ${overlaps.length}`); // debug
    if(overlaps.length >= 1)
      console.log(`totalcost() overlaps[0]: ${overlaps[0]}`); // debug
    if(overlaps.length >= 2)
      console.log(`totalcost() overlaps[1]: ${overlaps[1]}`); // debug
    if(overlaps.length >= 3)
      console.log(`totalcost() overlaps[2]: ${overlaps[2]}`); // debug
    // calculate cost of each overlap
    if(rateType === modconst.RATETYPE_PER_MINUTE_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_MINS;
    }
    else if(rateType === modconst.RATETYPE_PER_HOUR_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_HOURS;
    }
    else if(rateType === modconst.RATETYPE_PER_DAY_NATURAL) {
      durationType = caltime.constants.DURATION_NATURAL_DAYS;
    }
    console.log(`totalcost() durationType: ${durationType}`); // debug
    let measureResult = caltime.measureDateSpans(overlaps,
                                            durationType,
                                            inTZ);
    console.log(`totalcost() measureResult: ${measureResult}`); // debug
    console.log(`totalcost() rateType: ${rateType}`); // debug
    switch(rateType) {
      case modconst.RATETYPE_PER_MILLISECOND:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_SECOND_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_SEC) * rate;
        break;
      case modconst.RATETYPE_PER_SECOND_ROUNDUP:
        let durationSecs = Math.floor(measureResult / 1000);
        retval.cost = durationSecs * rate;
        if(durationSecs * 1000 < measureResult) {
          retval.cost += rate;
        }
        break;
      case modconst.RATETYPE_PER_MINUTE_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_MIN) * rate;
        break;
      case modconst.RATETYPE_PER_MINUTE_ROUNDUP:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_MINUTE_NATURAL:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_HOUR_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_HOUR) * rate;
        break;
      case modconst.RATETYPE_PER_HOUR_ROUNDUP:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_HOUR_NATURAL:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_DAY_PRORATA:
        retval.cost = (measureResult / caltime.constants.MSECS_PER_DAY) * rate;
        break;
      case modconst.RATETYPE_PER_DAY_ROUNDUP:
        retval.cost = measureResult * rate;
        break;
      case modconst.RATETYPE_PER_DAY_NATURAL:
        retval.cost = measureResult * rate;
        break;
    }
    // generate the remainders
    // TODO
    return retval;
  };

  /** private methods *********************************************************/

  // /**
  //  * Calculate the cost of a single DateSpan object.
  //  * @param {object} inDateSpan A valid DateSpan object.
  //  * @return {number} Floating point number with the cost of the DateSpan or
  //  * null if there is no overlap with interval of the CostRule.
  //  */
  // let costOf = function costOfFunc(inDateSpan) {
  //
  //   let retval = null;
  //   if (_.isObject(inDateSpan) === false) {
  //       throw new TypeError('Invalid argument. Must be of type DateSpan.');
  //   }
  //   // range of datespans for time-rule
  //   const ruleSpans = timerule.generateDateSpans(inDateSpan.getBegin(),
  //                                                 inDateSpan.getEnd());
  //   // identify all overlaps
  //   const overlaps = caltime.intersectDateSpans(ruleSpans, inDateSpans);
  //   // sum the cost of overlaps
  //   let i = 0;
  //   for(i=0; i<overlaps.length;i++) {
  //     let datespan = overlaps[i];
  //     if(retval === null) {
  //       retval = 0.0;
  //     }
  //     if()
  //   }
  //   return retval;
  // }

/* functional constructor return */
return that;
};


/** public functions **********************************************************/


/* interface exported by the module */
module.exports.costRule = costRule;


/** private functions *********************************************************/
